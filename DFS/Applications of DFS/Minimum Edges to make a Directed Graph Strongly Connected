Explanation : 
It's pretty common Graph Problem . We have to make the whole graph Stronhly Connected . That means we have to add some edges in a way such that it's possible to go from any vertex
to another .
Pre requisite for this Problem is One need to have a Idea about DFS,Strongly Connected Component . We know that in Strongly Connected Component it's possible to go from one vertex 
to another . So in our given graph if there exist a SCC then we don't need to add edges in this SCC . So first we will execute Simple Finding SCC algorithm and All the vertex of 
a SCC will be regarded as a single vertex . we will use an array to mark which vertex belongs to which SCC . So now our Step 1 is done . We have minimised the graph by making
all the vertex of a single SCC a single vertex by marking the vertices of that SCC by corresponding SCC number .
Now see , we know that a Directed Acyclic Graph can be a strongly Connected Component (SCC) ( in other words ,it possible to move from one vertex to another ) if every vertex of 
the DAG has atleast one edge that's getting into the vertex and atleast one edge going out from the vertex . That means if A vertex has atleast one indegree and one outgree .
Since we are now assuming the SCC as a single vertex so we will calculate the indegree and outdegree of each SCC . Now how to calculate it ???
we will run a DFS and check if two adjacent vertex are from different SCC ?? if they are from different SCC then we will increase the outdegree of the SCC where "node" belongs 
and increase the indegree of the SCC where "child" belongs .  now we will check how many SCC don't have atleast one indegree and then count How many SCC don't have atleast one
outgree . result will be the maximum of this two summation .



Code :

VL visited,topsort ;
vector < VL > graph ;
vector < VL > rgraph;
VL component,indegree,outdegree ;
ll SCC ;
void setting(ll n ) {
    graph.clear() ;
    graph.resize(n+3);
    rgraph.clear();
    rgraph.resize(n+3);
    visited.clear();
    visited.resize(n+3,0);
    topsort.clear();
    component.clear();
    component.resize(n+3,0);
    indegree.clear();
    indegree.resize(n+3,0);
    outdegree.clear();
    outdegree.resize(n+3,0);
}
void dfs1(ll node) {
    visited[node] = 1 ;
    for ( ll child : graph[node]) {
           if ( !visited[child]) dfs1(child); 
    }
    topsort.PB(node);
}
void dfs2(ll node) {
    visited[node] = 1 ;
    component[node] = SCC ;
    for ( ll child : rgraph[node]) {
           if ( !visited[child]) dfs2(child); 
    }
}
void dfs3(ll node) {
    visited[node] = 1 ;
    for ( ll child : graph[node] ) {
        if ( component[node] != component[child]) {
            outdegree[component[node]]++ ;
            indegree[component[child]]++  ;
        }
        if ( !visited[child]) dfs3(child);
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    ll t,c = 0 ;
    cin >> t ;
    while(t--) {
        ll vertex,edges ;
        cin >> vertex >> edges ;
        setting(vertex);   
        INC(i,1,edges) {
            ll node1,node2 ;
            cin >> node1 >> node2 ;
            graph[node1].PB(node2);
            rgraph[node2].PB(node1);
        }
        INC(i,1,vertex) {
            if ( !visited[i]) {
                dfs1(i);
            }
        }
        reverse(topsort.begin(),topsort.end());
        visited.clear();
        visited.resize(vertex+3,0);
        SCC = 0 ;
        INC(i,0,topsort.size()-1) {
            if ( !visited[topsort[i]]) {
                ++SCC ;
                dfs2(topsort[i]);
            }
        }
        visited.clear();
        visited.resize(vertex+3,0);
        INC(i,1,vertex) {
            if (!visited[i]) {
                dfs3(i);
            }
        }
        if ( SCC == 1) cout << "Case " << ++c << ": " << 0 << endl;
        else {
           ll insum  = 0 ;
           ll outsum = 0 ;
           INC(i,1,SCC) {
               if (!indegree[i]) insum++ ;
               if (!outdegree[i]) outsum++ ;
           }
           cout << "Case " << ++c << ": " << max(insum,outsum) << endl;
        }
    }
    return 0 ;
}
