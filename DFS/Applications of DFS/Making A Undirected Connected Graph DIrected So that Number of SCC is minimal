Problme Statement : A undirected Graph will be Given we need to give direction to the Edges and need to ensure that Number of Stronly Connected Component is Minimal as Possible .
So the Output Will be the Number of Strongly Connected Component . 

Explanation Link : It's Basically Known as String Orientation Of a graph .
             A good article Regarding this : https://cp-algorithms.com/graph/strong-orientation.html
             
Explanation : It's Just a simple Modification of Finding Articulation Bridge Algorithm . Look If there is a bridge in a graph That means there doesn't exist any back edge  from
the child to it's parent node or any of it's ancestor .  So even if we can go from  parent node 'U' to any of its descendant nodes connected through that edge or Bridge There is 
no way to come back from descendant nodes to that parent node 'U' . So we need to compromise atleast one direction . So the Current Stronly Connected Component Ends here . At 
this point we will increase the the value of the variable which will keep the Count of Bridges . We need to if any of the edges is used before or not .if the edge is from 
"Node to child" according to the variable used in Described Below we will give a value "1"  and if the edge is from "Child to Node" we will give value "-1" . So this few things 
are extra which we need to check Apart from running the simple Articualtion Bridge Algorithm .
Number Of total Strongly Connected Component Will be the Number of Bridges + Connected Components . Because If we remove the Bridges From the Graph We end up with some number 
of bridgeless components (exactly how many components there were at the beginning + how many bridges there were) .


ll vertex,NumberOfedges ;
vector < PLL > graph[1005] ;
VL edges_visited , vertex_visited,low,in,edge_direction,parent;
VLL edges ;
ll t = 0 ;
ll bridges = 0 ;
void setting(ll n , ll m) {
    INC(i,0,1004) graph[i].clear();
    edges_visited.clear();
    edges_visited.resize(m+5);
    vertex_visited.clear();
    vertex_visited.resize(n+5);
    low.clear();
    low.resize(n+5);
    in.clear();
    in.resize(n+5);
    edges.clear();
    edges.resize(m+5);
    edge_direction.clear();
    edge_direction.resize(m+5);
    parent.clear();
    parent.resize(n+5);
}
void dfs(ll node) {
     vertex_visited[node] = 1;
     low[node] = in[node] = ++t ;
     for ( PLL child : graph[node]) {
         if ( edges_visited[child.S]) continue ;                                  // Checking If the edges is used before .
         edges_visited[child.S] = 1 ;
         if ( edges[child.S].F == node ) edge_direction[child.S] = 1 ;           // giving direction from node to child
         else edge_direction[child.S] = -1 ;                                     // giving direction from child to node
         if (!vertex_visited[child.F]) {
             parent[child.F] = node ;
             dfs(child.F);
             low[node] = min(low[node],low[child.F]);
             if ( low[child.F] > in[node]) {
                 bridges++ ;
             }
         }
        else if ( parent[node] != child.F) {
               low[node] = min(low[node],in[child.F]);
        }
     }

}
 
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> vertex >> NumberOfedges ;
    setting(vertex,NumberOfedges);
    INC(i,1,NumberOfedges) {
        ll node1,node2 ;
        cin >> node1 >> node2 ;
        graph[node1].PB({node2,i});
        graph[node2].PB({node1,i});   
        edges[i] = {node1,node2};
    } 
    ll CC = 0 ;
    INC(i,1,vertex) {
        if ( !vertex_visited[i]) {
            CC++ ;
            dfs(i);
        }
    }
    cout << "Number Of Strongly Connected Components " << CC+bridges << endl;
    cout << "Direction Of edges from 1 to NumberOfedges : " << endl;
    INC(i,1,NumberOfedges) {
        if ( edge_direction[i] == 1) cout << edges[i].F << " " << edges[i].S << endl;
        else if ( edge_direction[i] == -1) cout << edges[i].S << " " << edges[i].F << endl;
    }

    return 0 ;
}
